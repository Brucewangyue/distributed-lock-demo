# 多种分布式锁的代码实现

## 目录
- eureka-server：服务注册中心
- eureka-order: 订单服务，存放所有锁的实现
- eureka-client1: 客户端，用于测试负载访问多个eureka-order

## 锁实现
- mysql 实现了一个简单的锁
- redis 原生手写实现了一个简单的锁
- redisson 单机锁
- redisson 集群锁-红锁
- aop+注解封装了锁

## 红锁的实现原理  [img](https://www.processon.com/diagraming/608a6ea5f346fb7dd391b8da)
1、每台redis节点都是互相独立，没有任何联系
2、加锁的时候都是按一个固定的节点顺序去加锁
3、加锁成功的节点未过半，或者加锁总时长超过了锁的有效期需要删除其余成功的锁



## 分布式锁的效率

  分布式锁主要是解决共享资源被多人同时修改的问题
  以上的锁都能完成资源的锁定，都是直接阻塞请求，相当于在的排队等待，如果并发高，这个队伍就会排的非常长， 
排在后面的人需要等待的时间也会越久
  
- 1、将需要锁定的共享资源分批次、分段，比如库存100，分成10份每份10个，这样效率就提高了10倍，实现方式：
  - 原本redis上对于这个库存只有一个锁，假如是item_count
  - 现在将这个锁拆分成10份:item_count_1,item_count_2,...
  - 获取锁的时候，按锁的顺序去一个一个的获取锁，直到获取到其中一把锁，如果10把锁都获取不到就重复
- 2、请求的服务路径要短
- 3、依赖的服务少
- 4、请求量少（在前面通过筛选过滤无效请求）
